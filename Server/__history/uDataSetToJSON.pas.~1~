unit uDataSetToJSON;

interface

uses
  System.SysUtils,
  System.Classes,
  System.JSON,
  System.DateUtils,
  System.NetEncoding,
  System.TypInfo,
  Data.SqlTimSt,
  Data.FmtBcd,
  Data.DB;

function DataSetToJSONArray(dataSet: TDataSet): TJSONArray;
function DataSetToJSONObject(dataSet: TDataSet): TJSONObject;

implementation

type
  EDataSetConverterException = class(Exception);
  TBooleanFieldType = (bfUnknown, bfBoolean, bfInteger);
  TDataSetFieldType = (dfUnknown, dfJSONObject, dfJSONArray);

//function DateTimeToISOTimeStamp(const dateTime: TDateTime): string;
//function DateToISODate(const date: TDateTime): string;
//function TimeToISOTime(const time: TTime): string;
//
//function ISOTimeStampToDateTime(const dateTime: string): TDateTime;
//function ISODateToDate(const date: string): TDate;
//function ISOTimeToTime(const time: string): TTime;
//
//function NewDataSetField(dataSet: TDataSet; const fieldType: TFieldType; const fieldName: string;
//  const size: Integer = 0; const origin: string = ''; const displaylabel: string = ''): TField;
//
//function BooleanToJSON(const value: Boolean): TJSONValue;
//function BooleanFieldToType(const booleanField: TBooleanField): TBooleanFieldType;
//function DataSetFieldToType(const dataSetField: TDataSetField): TDataSetFieldType;
//function MakeValidIdent(const s: string): string;


function DateTimeToISOTimeStamp(const dateTime: TDateTime): string;
var
  fs: TFormatSettings;
begin
  fs.TimeSeparator := ':';
  Result := FormatDateTime('yyyy-mm-dd hh:nn:ss', dateTime, fs);
end;

function DateToISODate(const date: TDateTime): string;
begin
  Result := FormatDateTime('YYYY-MM-DD', date);
end;

function TimeToISOTime(const time: TTime): string;
var
  fs: TFormatSettings;
begin
  fs.TimeSeparator := ':';
  Result := FormatDateTime('hh:nn:ss', time, fs);
end;

function ISOTimeStampToDateTime(const dateTime: string): TDateTime;
begin
  Result := EncodeDateTime(StrToInt(Copy(dateTime, 1, 4)), StrToInt(Copy(dateTime, 6, 2)), StrToInt(Copy(dateTime, 9, 2)),
    StrToInt(Copy(dateTime, 12, 2)), StrToInt(Copy(dateTime, 15, 2)), StrToInt(Copy(dateTime, 18, 2)), 0);
end;

function ISODateToDate(const date: string): TDate;
begin
  Result := EncodeDate(StrToInt(Copy(date, 1, 4)), StrToInt(Copy(date, 6, 2)), StrToInt(Copy(date, 9, 2)));
end;

function ISOTimeToTime(const time: string): TTime;
begin
  Result := EncodeTime(StrToInt(Copy(time, 1, 2)), StrToInt(Copy(time, 4, 2)), StrToInt(Copy(time, 7, 2)), 0);
end;

function MakeValidIdent(const s: string): string;
var
  x: Integer;
  c: Char;
begin
  SetLength(Result, Length(s));
  x := 0;

  for c in s do
  begin
    if CharInSet(c, ['A'..'Z', 'a'..'z', '0'..'9', '_']) then
    begin
      Inc(x);
      Result[x] := c;
    end;
  end;

  SetLength(Result, x);

  if x = 0 then
    Result := '_'
  else if CharInSet(Result[1], ['0'..'9']) then
    Result := '_' + Result;
end;

function NewDataSetField(dataSet: TDataSet; const fieldType: TFieldType; const fieldName: string;
  const size: Integer = 0; const origin: string = ''; const displaylabel: string = ''): TField;
begin
  Result := DefaultFieldClasses[fieldType].Create(dataSet);
  Result.FieldName := fieldName;

  if (Result.FieldName = '') then
    Result.FieldName := 'Field' + IntToStr(dataSet.FieldCount + 1);

  Result.FieldKind := fkData;
  Result.DataSet := dataSet;
  Result.Name := MakeValidIdent(dataSet.Name + Result.FieldName);
  Result.Size := size;
  Result.Origin := origin;
  if not(displaylabel.IsEmpty) then
    Result.DisplayLabel := displaylabel;

  if (fieldType in [ftString, ftWideString]) and (size <= 0) then
    raise EDataSetConverterException.CreateFmt('Size not defined for field "%s".', [fieldName]);
end;

function BooleanToJSON(const value: Boolean): TJSONValue;
begin
  if value then
    Result := TJSONTrue.Create
  else
    Result := TJSONFalse.Create;
end;

function BooleanFieldToType(const booleanField: TBooleanField): TBooleanFieldType;
const
  DESC_BOOLEAN_FIELD_TYPE: array [TBooleanFieldType] of string = ('Unknown', 'Boolean', 'Integer');
var
  index: Integer;
  origin: string;
begin
  Result := bfUnknown;
  origin := Trim(booleanField.Origin);
  for index := Ord(Low(TBooleanFieldType)) to Ord(High(TBooleanFieldType)) do
    if (LowerCase(DESC_BOOLEAN_FIELD_TYPE[TBooleanFieldType(index)]) = LowerCase(origin)) then
      Exit(TBooleanFieldType(index));
end;

function DataSetFieldToType(const dataSetField: TDataSetField): TDataSetFieldType;
const
  DESC_DATASET_FIELD_TYPE: array [TDataSetFieldType] of string = ('Unknown', 'JSONObject', 'JSONArray');
var
  index: Integer;
  origin: string;
begin
  Result := dfUnknown;
  origin := Trim(dataSetField.Origin);
  for index := Ord(Low(TDataSetFieldType)) to Ord(High(TDataSetFieldType)) do
    if (LowerCase(DESC_DATASET_FIELD_TYPE[TDataSetFieldType(index)]) = LowerCase(origin)) then
      Exit(TDataSetFieldType(index));
end;

function DataSetToJSONArray(dataSet: TDataSet): TJSONArray;
var
  bookMark: TBookmark;
begin
  Result := nil;
  if Assigned(dataSet) and (not dataSet.IsEmpty) then
    try
      Result := TJSONArray.Create;
      bookMark := dataSet.Bookmark;
      dataSet.First;
      while not dataSet.Eof do
      begin
        Result.AddElement(DataSetToJSONObject(dataSet));
        dataSet.Next;
      end;
    finally
      if dataSet.BookmarkValid(bookMark) then
        dataSet.GotoBookmark(bookMark);
      dataSet.FreeBookmark(bookMark);
    end;
end;

function DataSetToJSONObject(dataSet: TDataSet): TJSONObject;
var
  i: Integer;
  key: string;
  timeStamp: TSQLTimeStamp;
  nestedDataSet: TDataSet;
  dft: TDataSetFieldType;
  bft: TBooleanFieldType;
  ms: TMemoryStream;
  ss: TStringStream;
begin
  Result := nil;
  if Assigned(dataSet) and (not dataSet.IsEmpty) then
  begin
    Result := TJSONObject.Create;
    for i := 0 to Pred(dataSet.FieldCount) do
    begin
      if dataSet.Fields[i].Visible then
      begin
        key := dataSet.Fields[i].FieldName;
        case dataSet.Fields[i].DataType of
          TFieldType.ftBoolean:
            begin
              bft := BooleanFieldToType(TBooleanField(dataSet.Fields[i]));
              case bft of
                bfUnknown, bfBoolean: Result.AddPair(key, BooleanToJSON(dataSet.Fields[i].AsBoolean));
                bfInteger: Result.AddPair(key, TJSONNumber.Create(dataSet.Fields[i].AsInteger));
              end;
            end;
          TFieldType.ftInteger, TFieldType.ftSmallint, TFieldType.ftShortint:
            Result.AddPair(key, TJSONNumber.Create(dataSet.Fields[i].AsInteger));
          TFieldType.ftLongWord, TFieldType.ftAutoInc:
            begin
              if not dataSet.Fields[i].IsNull then
                Result.AddPair(key, TJSONNumber.Create(dataSet.Fields[i].AsWideString))
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftLargeint:
            Result.AddPair(key, TJSONNumber.Create(dataSet.Fields[i].AsLargeInt));
          TFieldType.ftSingle, TFieldType.ftFloat:
            Result.AddPair(key, TJSONNumber.Create(dataSet.Fields[i].AsFloat));
          ftString, ftWideString, ftMemo, ftWideMemo:
            begin
              if not dataSet.Fields[i].IsNull then
                Result.AddPair(key, TJSONString.Create(dataSet.Fields[i].AsWideString))
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftDate:
            begin
              if not dataSet.Fields[i].IsNull then
                Result.AddPair(key, TJSONString.Create(DateToISODate(dataSet.Fields[i].AsDateTime)))
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftTimeStamp, TFieldType.ftDateTime:
            begin
              if not dataSet.Fields[i].IsNull then
                Result.AddPair(key, TJSONString.Create(DateTimeToISOTimeStamp(dataSet.Fields[i].AsDateTime)))
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftTime:
            begin
              if not dataSet.Fields[i].IsNull then
              begin
                timeStamp := dataSet.Fields[i].AsSQLTimeStamp;
                Result.AddPair(key, TJSONString.Create(SQLTimeStampToStr('hh:nn:ss', timeStamp)));
              end
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftCurrency:
            begin
              if not dataSet.Fields[i].IsNull then
                Result.AddPair(key, TJSONString.Create(FormatCurr('0.00##', dataSet.Fields[i].AsCurrency)))
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftFMTBcd, TFieldType.ftBCD:
            begin
              if not dataSet.Fields[i].IsNull then
                Result.AddPair(key, TJSONNumber.Create(BcdToDouble(dataSet.Fields[i].AsBcd)))
              else
                Result.AddPair(key, TJSONNull.Create);
            end;
          TFieldType.ftDataSet:
            begin
              dft := DataSetFieldToType(TDataSetField(dataSet.Fields[i]));
              nestedDataSet := TDataSetField(dataSet.Fields[i]).NestedDataSet;
              case dft of
                dfJSONObject:
                  Result.AddPair(key, DataSetToJSONObject(nestedDataSet));
                dfJSONArray:
                  Result.AddPair(key, DataSetToJSONArray(nestedDataSet));
              end;
            end;
          TFieldType.ftGraphic, TFieldType.ftBlob, TFieldType.ftStream:
            begin
              ms := TMemoryStream.Create;
              try
                TBlobField(dataSet.Fields[I]).SaveToStream(ms);
                ms.Position := 0;
                ss := TStringStream.Create;
                try
                  TNetEncoding.Base64.Encode(ms, ss);
                  Result.AddPair(key, TJSONString.Create(ss.DataString));
                finally
                  ss.Free;
                end;
              finally
                ms.Free;
              end;
            end;
          TFieldType.ftGuid:
          begin
            Result.AddPair(key, DataSet.Fields[I].AsString);
          end;
        else
          raise EDataSetConverterException.CreateFmt('Cannot find type for field "%s"', [key]);
        end;
      end;
    end;
  end;
end;

end.
